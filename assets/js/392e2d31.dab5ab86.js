"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[9602],{3084:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>d,frontMatter:()=>i,metadata:()=>a,toc:()=>l});var o=r(4848),t=r(8453);const i={sidebar_position:4},s="Memory Management",a={id:"CMND React sdk/memory",title:"Memory Management",description:"Introduction",source:"@site/docs/CMND React sdk/memory.md",sourceDirName:"CMND React sdk",slug:"/CMND React sdk/memory",permalink:"/docs/CMND React sdk/memory",draft:!1,unlisted:!1,editUrl:"https://github.com/CyprusCodes/cmnd-docs/tree/main/docs/CMND React sdk/memory.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4},sidebar:"tutorialSidebar",previous:{title:"Custom Styles",permalink:"/docs/CMND React sdk/custom_styles"},next:{title:"UI Tools",permalink:"/docs/CMND React sdk/ui_tools"}},c={},l=[{value:"Introduction",id:"introduction",level:2},{value:"Memory Features",id:"memory-features",level:2},{value:"Initial Memory Setup",id:"initial-memory-setup",level:3},{value:"Memory Management Functions",id:"memory-management-functions",level:3},{value:"setCurrentConversationMemory",id:"setcurrentconversationmemory",level:4},{value:"deleteCurrentConversationMemory",id:"deletecurrentconversationmemory",level:4},{value:"Usage Example",id:"usage-example",level:2},{value:"Best Practices",id:"best-practices",level:2}];function m(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"memory-management",children:"Memory Management"})}),"\n",(0,o.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,o.jsxs)(n.p,{children:["The CMND React SDK provides memory management capabilities that allow you to store and manage conversation context through the ",(0,o.jsx)(n.code,{children:"initialMemory"})," prop and memory management functions. Refer to the ",(0,o.jsx)(n.a,{href:"/docs/tools_config/memory-object",children:"Memory Object Documentation\n"})," for more information on when you should leverage ",(0,o.jsx)(n.code,{children:"memory"})," object in your extensions."]}),"\n",(0,o.jsx)(n.h2,{id:"memory-features",children:"Memory Features"}),"\n",(0,o.jsx)(n.h3,{id:"initial-memory-setup",children:"Initial Memory Setup"}),"\n",(0,o.jsxs)(n.p,{children:["You can initialize the chat with predefined memory values using the ",(0,o.jsx)(n.code,{children:"initialMemory"})," prop when setting up the ChatProvider:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:'<ChatProvider\n  baseUrl="<your-cmnd-api-base-url>"\n  chatbotId={"<your-chatbot-id>"}\n  organizationId={"<your-organization-id>"}\n  initialMemory={{\n    accessToken: "your-access-token",\n    date: "2022-01-01",\n    // Add any other initial memory key-value pairs\n  }}\n/>\n'})}),"\n",(0,o.jsx)(n.h3,{id:"memory-management-functions",children:"Memory Management Functions"}),"\n",(0,o.jsx)(n.p,{children:"The SDK provides two main functions for managing conversation memory:"}),"\n",(0,o.jsx)(n.h4,{id:"setcurrentconversationmemory",children:"setCurrentConversationMemory"}),"\n",(0,o.jsx)(n.p,{children:"Allows you to set or update memory values during an active conversation."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:'import { setCurrentConversationMemory } from "@cmnd-ai/chatbot-react";\n\n// Set single or multiple memory values\nawait setCurrentConversationMemory({\n  name: "John Doe",\n  email: "jon@doe.com",\n  phone: "1234567890",\n});\n'})}),"\n",(0,o.jsx)(n.admonition,{type:"warning",children:(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"setCurrentConversationMemory"})," method is only available when user is interacting with an active chat thread."]})}),"\n",(0,o.jsx)(n.h4,{id:"deletecurrentconversationmemory",children:"deleteCurrentConversationMemory"}),"\n",(0,o.jsx)(n.p,{children:"Enables you to remove specific memory keys from the current conversation."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:'import { deleteCurrentConversationMemory } from "@cmnd-ai/chatbot-react";\n\n// Delete a specific memory key\nawait deleteCurrentConversationMemory("name");\n'})}),"\n",(0,o.jsx)(n.admonition,{type:"warning",children:(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"deleteCurrentConversationMemory"})," method is only available when user is interacting with an active chat thread."]})}),"\n",(0,o.jsx)(n.h2,{id:"usage-example",children:"Usage Example"}),"\n",(0,o.jsx)(n.p,{children:"Here's a complete example showing how to implement memory management in your chat application:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:'import { ChatProvider } from "@cmnd/react-sdk";\nimport {\n  setCurrentConversationMemory,\n  deleteCurrentConversationMemory,\n} from "@cmnd-ai/chatbot-react";\n\nfunction ChatApp() {\n  const handleSetMemory = async () => {\n    try {\n      const response = await setCurrentConversationMemory({\n        name: "John Doe",\n        email: "jon@doe.com",\n        phone: "1234567890",\n      });\n      console.log("Memory Set:", response);\n    } catch (error) {\n      console.error("Error setting memory:", error);\n    }\n  };\n\n  const handleDeleteMemory = async () => {\n    try {\n      const response = await deleteCurrentConversationMemory("name");\n      console.log("Memory Deleted:", response);\n    } catch (error) {\n      console.error("Error deleting memory:", error);\n    }\n  };\n\n  return (\n    <>\n      <ChatProvider\n        baseUrl="<your-cmnd-api-base-url>"\n        chatbotId={"<your-chatbot-id>"}\n        organizationId={"<your-organization-id>"}\n        initialMemory={{\n          accessToken: "your-access-token",\n          date: "2022-01-01",\n        }}\n      />\n      <Button onClick={handleSetMemory}>Set Memory</Button>\n      <Button onClick={handleDeleteMemory}>Delete Memory</Button>\n    </>\n  );\n}\n'})}),"\n",(0,o.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Security Considerations"})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Don't store anything sensitive in memory, as it's not meant for secure storage."}),"\n",(0,o.jsx)(n.li,{children:"Regularly clean up unnecessary memory entries"}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Performance Optimization"})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Only store essential information in memory"}),"\n",(0,o.jsx)(n.li,{children:"Clear outdated memory values when no longer needed"}),"\n",(0,o.jsx)(n.li,{children:"Avoid storing large data structures in memory"}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Error Handling"})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Implement proper error handling for memory operations"}),"\n",(0,o.jsx)(n.li,{children:"Validate memory values before storage"}),"\n",(0,o.jsx)(n.li,{children:"Provide feedback for failed memory operations"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.admonition,{type:"note",children:(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Memory values persist only for the current conversation session"}),"\n",(0,o.jsx)(n.li,{children:"Memory operations are asynchronous and return Promises"}),"\n",(0,o.jsx)(n.li,{children:"Ensure proper error handling for memory management functions"}),"\n",(0,o.jsx)(n.li,{children:"Memory keys should be strings and values should be serializable"}),"\n"]})})]})}function d(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(m,{...e})}):m(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>s,x:()=>a});var o=r(6540);const t={},i=o.createContext(t);function s(e){const n=o.useContext(i);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:s(e.components),o.createElement(i.Provider,{value:n},e.children)}}}]);