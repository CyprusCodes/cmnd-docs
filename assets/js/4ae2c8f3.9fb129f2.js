"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[3935],{7335:(e,o,t)=>{t.r(o),t.d(o,{assets:()=>a,contentTitle:()=>l,default:()=>d,frontMatter:()=>n,metadata:()=>r,toc:()=>c});var s=t(4848),i=t(8453);const n={sidebar_position:1},l="Post Tool Call Prompting",r={id:"tools_config/post-tool-call-prompt",title:"Post Tool Call Prompting",description:"Overview",source:"@site/docs/tools_config/post-tool-call-prompt.md",sourceDirName:"tools_config",slug:"/tools_config/post-tool-call-prompt",permalink:"/docs/tools_config/post-tool-call-prompt",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/tools_config/post-tool-call-prompt.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Tool Configuration",permalink:"/docs/category/tool-configuration"},next:{title:"Rerun",permalink:"/docs/tools_config/rerun"}},a={},c=[{value:"Overview",id:"overview",level:2},{value:"What is Post-Tool Call Prompting?",id:"what-is-post-tool-call-prompting",level:2},{value:"How can we implement Post-Tool Call Prompting in CMND?",id:"how-can-we-implement-post-tool-call-prompting-in-cmnd",level:2},{value:"Here is how Post-Tool Call Prompting comes into play:",id:"here-is-how-post-tool-call-prompting-comes-into-play",level:2},{value:"Conclusion",id:"conclusion",level:2}];function h(e){const o={h1:"h1",h2:"h2",header:"header",img:"img",li:"li",ol:"ol",p:"p",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(o.header,{children:(0,s.jsx)(o.h1,{id:"post-tool-call-prompting",children:"Post Tool Call Prompting"})}),"\n",(0,s.jsx)(o.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsx)(o.p,{children:"In AI-driven applications, ensuring the smooth interaction between users, tools, and the LLM is essential. To address the challenge of controlling LLM behavior based on tool outputs, we are introducing a technique called Post-Tool Call Prompting. This technique allows developers to adjust the behavior of the LLM after the tool executes and before the LLM gives the results to the user, enabling specific flows based on the outcomes of the tools used."}),"\n",(0,s.jsx)(o.h2,{id:"what-is-post-tool-call-prompting",children:"What is Post-Tool Call Prompting?"}),"\n",(0,s.jsx)(o.p,{children:'Post-Tool Call Prompting is a strategy where a message with a role of "user" and the property "hiddenFromUser": true is injected into the conversation. Although this message is invisible to the user, it serves an essential function for the LLM, guiding its behavior when working with tools. This hidden message helps create pre-defined conditions and actions for the LLM to follow based on the tool\'s execution results.'}),"\n",(0,s.jsx)(o.p,{children:"By utilizing this technique, you can condition the LLM to respond differently depending on the outcome of tool operations, thus improving the flow and user experience."}),"\n",(0,s.jsx)(o.h2,{id:"how-can-we-implement-post-tool-call-prompting-in-cmnd",children:"How can we implement Post-Tool Call Prompting in CMND?"}),"\n",(0,s.jsx)(o.p,{children:"Consider the example where a user is logging into a system. The process involves the user providing their username and password, which are then sent to a backend tool to validate the credentials. The flow of the conversation with the LLM may need to adjust based on the tool's response\u2014whether it's a success or failure."}),"\n",(0,s.jsx)(o.h2,{id:"here-is-how-post-tool-call-prompting-comes-into-play",children:"Here is how Post-Tool Call Prompting comes into play:"}),"\n",(0,s.jsxs)(o.ol,{children:["\n",(0,s.jsxs)(o.li,{children:["\n",(0,s.jsx)(o.p,{children:"User Interaction:\nThe user provides their login credentials, which are passed to the backend tool to process."}),"\n"]}),"\n",(0,s.jsxs)(o.li,{children:["\n",(0,s.jsx)(o.p,{children:'Post-Tool Call Prompting:\nA hidden message is sent with the role of "user" and "hiddenFromUser": true. This message contains instructions that condition the behavior of the LLM based on the tool\'s output.'}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(o.p,{children:"Here\u2019s a visual example to illustrate how this technique is implemented."}),"\n",(0,s.jsx)(o.p,{children:(0,s.jsx)(o.img,{alt:"../../static/img/assistants.png",src:t(4691).A+"",width:"2456",height:"1058"})}),"\n",(0,s.jsx)(o.p,{children:"Flow of Messages: The flow of messages in the conversation would look like this:"}),"\n",(0,s.jsx)(o.p,{children:(0,s.jsx)(o.img,{alt:"../../static/img/assistants.png",src:t(3949).A+"",width:"787",height:"1255"})}),"\n",(0,s.jsx)(o.p,{children:"In this flow, after the tool attempts to validate the user's credentials, the hidden message will prompt the LLM to handle the failure case by asking the user to retry. This is all done without the user being aware of the hidden instructions guiding the LLM's behavior."}),"\n",(0,s.jsx)(o.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,s.jsx)(o.p,{children:"Post-Tool Call Prompting is a powerful technique that allows developers to adjust the behavior of LLMs in real time based on the outcomes of tool executions. By injecting hidden messages that guide the LLM after a tool completes, developers can manage different scenarios such as failures or successes more effectively, ensuring that users have a smooth and intuitive experience."}),"\n",(0,s.jsx)(o.p,{children:"This technique is particularly useful for applications that rely heavily on backend tools to process user requests, as it provides a seamless way to handle complex workflows without compromising the user experience."})]})}function d(e={}){const{wrapper:o}={...(0,i.R)(),...e.components};return o?(0,s.jsx)(o,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},3949:(e,o,t)=>{t.d(o,{A:()=>s});const s=t.p+"assets/images/messages-array-3f1fcfb12bcb430d0476f9a7d34188ab.png"},4691:(e,o,t)=>{t.d(o,{A:()=>s});const s=t.p+"assets/images/post-tool-call-f85de7e7cf70a677a3fa3daa148585cc.png"},8453:(e,o,t)=>{t.d(o,{R:()=>l,x:()=>r});var s=t(6540);const i={},n=s.createContext(i);function l(e){const o=s.useContext(n);return s.useMemo((function(){return"function"==typeof e?e(o):{...o,...e}}),[o,e])}function r(e){let o;return o=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),s.createElement(n.Provider,{value:o},e.children)}}}]);